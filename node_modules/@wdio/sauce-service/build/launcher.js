"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("util");

var _perf_hooks = require("perf_hooks");

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _sauceConnectLauncherUpdate = _interopRequireDefault(require("sauce-connect-launcher-update"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function modifyObject(root, propertiesObject) {
  for (const [k, v] of Object.entries(propertiesObject)) {
    root[k] = v;
  }
}

const log = (0, _logger.default)('@wdio/sauce-service');

class SauceLauncher {
  constructor(options) {
    this.options = options;
  }

  async onPrepare(config, capabilities) {
    if (!this.options.sauceConnect) {
      return;
    }

    const sauceConnectOpts = this.options.sauceConnectOpts || {};
    const sauceConnectTunnelIdentifier = sauceConnectOpts.tunnelIdentifier || `SC-tunnel-${Math.random().toString().slice(2)}`;
    this.sauceConnectOpts = _objectSpread({
      noAutodetect: true,
      username: config.user,
      accessKey: config.key,
      logger: log.debug,
      tunnelIdentifier: sauceConnectTunnelIdentifier
    }, config.region === 'eu' ? {
      '-x': 'https://eu-central-1.saucelabs.com/rest/v1'
    } : {}, {}, sauceConnectOpts);
    let endpointConfigurations = {};

    if (this.options.scRelay) {
      endpointConfigurations = {
        protocol: 'http',
        hostname: 'localhost',
        port: this.sauceConnectOpts.port || 4445
      };
    }

    if (Array.isArray(capabilities)) {
      for (const capability of capabilities) {
        if (!capability['sauce:options']) {
          capability['sauce:options'] = {};
        }

        modifyObject(capability, endpointConfigurations);
        capability['sauce:options'].tunnelIdentifier = capability.tunnelIdentifier || capability['sauce:options'].tunnelIdentifier || sauceConnectTunnelIdentifier;
        delete capability.tunnelIdentifier;
      }
    } else {
      for (const browserName of Object.keys(capabilities)) {
        if (!capabilities[browserName].capabilities['sauce:options']) {
          capabilities[browserName].capabilities['sauce:options'] = {};
        }

        modifyObject(capabilities[browserName].capabilities, endpointConfigurations);
        capabilities[browserName].capabilities['sauce:options'].tunnelIdentifier = capabilities[browserName].capabilities.tunnelIdentifier || capabilities[browserName].capabilities['sauce:options'].tunnelIdentifier || sauceConnectTunnelIdentifier;
        delete capabilities[browserName].capabilities.tunnelIdentifier;
      }
    }

    const obs = new _perf_hooks.PerformanceObserver(list => {
      const entry = list.getEntries()[0];
      log.info(`Sauce Connect successfully started after ${entry.duration}ms`);
    });
    obs.observe({
      entryTypes: ['measure'],
      buffered: false
    });

    _perf_hooks.performance.mark('sauceConnectStart');

    this.sauceConnectProcess = await (0, _util.promisify)(_sauceConnectLauncherUpdate.default)(this.sauceConnectOpts);

    _perf_hooks.performance.mark('sauceConnectEnd');

    _perf_hooks.performance.measure('bootTime', 'sauceConnectStart', 'sauceConnectEnd');
  }

  onComplete() {
    if (!this.sauceConnectProcess) {
      return;
    }

    return new Promise(resolve => this.sauceConnectProcess.close(resolve));
  }

}

exports.default = SauceLauncher;